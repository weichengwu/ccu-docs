# 报文格式

报文统一使用 JSON 格式进行封装，在报文的头尾分别加入 `!` 和 `$` 进行区分。

完整报文格式：`!{json_obj}$`。

## 报文类型

报文又分为请求报文和响应报文，它们根据数据的流向进行区分。

* 请求报文：客户端 -> 中控
* 响应报文：中控 -> 客户端
* 推送报文：中控 -> 客户端（中控内数据发生变化时主动向客户端发送，不需要客户端发起请求）

## 报文内容

请求报文和响应报文的内容结构（JSON 对象的根字段）有所不同，下面是详细的字段说明：

### 请求

| 参数      | 类型     | 含义           | 备注                      |
| --------- | -------- | -------------- | ------------------------- |
| reqId     | string   | 唯一标识符     | 建议使用 `UUID` 随机生成  |
| nodeId    | string   | 目标id         | 如果没有，则使用 `*` 代替 |
| opcode    | string   | 操作码         | 表示想要执行的操作        |
| arg       | 动态变化 | 参数           | 如果没有，则使用 `*` 代替 |
| requester | string   | 目标服务处理器 |                           |

### 响应

| 参数      | 类型     | 含义       | 备注                  |
| --------- | -------- | ---------- | --------------------- |
| reqId     | string   | 唯一标识符 | 与请求相同或者 `null` |
| nodeId    | string   | 目标id     | 一般与请求相同        |
| opcode    | string   | 操作码     | 一般与请求相同        |
| arg       | 动态变化 | 参数       | 如果没有，则返回 `*`  |
| status    | string   | 处理结果   | `success / failed`    |
| errorinfo | object   | 错误信息   | 只有反馈失败时才出现  |

`errorinfo` 的格式：

```json
{
    "error_code": 10001,
    "error_msg": "..."
}
```

### 完整示例

以下操作表示打开 id 为 1 的网关的组网通道，操作结果为成功。

<!-- tabs:start -->

#### ** 请求 **

```json
{
    "reqId": "xxx",
    "nodeid": 1,
    "opcode": "OPEN_NET_CHANNEL",
    "arg": "*",
    "requester": "HJ_Server"
}
```

#### ** 响应 **

```json
{
    "reqId": "xxx",
    "nodeid": 1,
    "opcode": "OPEN_NET_CHANNEL",
    "arg": "*",
    "status": "success"
}
```

<!-- tabs:end -->

> [!NOTE]
> 关于 `reqId`
>   * 现所有 ZigBee 控制类均不支持 `reqId` 机制
>   * 当中控反馈报文中无 `reqId` 字段，或 `reqId` 为 `null` 时，应采用原报文指纹方式来追踪请求上下文（后面会有专门的说明）。
> 
> 关于 `errorinfo`
>   * 历史版本协议（1.58 版本之前）无错误码机制，且目前并非所有交互都支持错误码机制。
>   * 上层开发时需要判断是否有该字段，若无那么表明当前并不支持错误码。
>
> 关于 `nodeId`
>   * 控制目标为节点设备时，表示节点设备的 id
>   * 控制目标为 IFTTT、情景模式等虚拟设备时，表示虚拟设备的 id
>   * 控制目标为网关时，表示网关的 id
>   * 控制目标不是具体设备时，比如切换主机安防状态，统一使用 `*` 代替